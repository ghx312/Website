<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../style.css">
</head>
<body>
  <div class="overlay">

    <!-- üîπ Navigation Header -->
    <div class="header">
      <a class="tab" href="main.html">Introduction</a>
      <a class="tab" href="resources.html">Resources</a>
      <a class="tab" href="writeups.html">Writeups</a>
      <a class="tab" href="misc.html">Miscellaneous</a>
      <a class="tab" href="about.html">About</a>
    </div>

    <!-- üîπ Page Content -->
    <div class="content">
    <h2>Modular Arithmetic Manipulation</h2>
    <ul>
      <li>(a + x<sub>b</sub> + x) mod p</li>
      <li>(a ‚àí x<sub>b</sub> ‚àí x) mod p</li>
      <li>(a √ó x<sub>b</sub> √ó x) mod p</li>
      <li>(a<sup>x<sub>b</sub></sup> √ó x) mod p</li>
      <li>(a + b) mod p = (a mod p) + (b mod p)</li>
      <li>(a √ó b) mod p = (a mod p) √ó (b mod p)</li>
      <li>(a √ó d<sub>b</sub> √ó d) mod p = a √ó b mod (p / gcd(d, p))</li>
    </ul>
    
    <h2>Greatest Common Divisor</h2>
    <p>gcd(a, b) = 1 ‚Üí a and b are coprime (relatively prime).  
    Used to find inverses in the Chinese Remainder Theorem.</p>
    
    <h2>Euclid‚Äôs Algorithm</h2>
    <p>a = k √ó b + c<sub>1</sub>, where c<sub>1</sub> &lt; b  
    b = k √ó c<sub>1</sub> + c<sub>2</sub>, where c<sub>2</sub> &lt; c<sub>1</sub></p>
    <p>Continue until c<sub>n</sub> = k √ó c<sub>n+1</sub> + 0.  
    The previous remainder is gcd(a, b).</p>
    
    <h2>Extended Euclid‚Äôs Algorithm</h2>
    <p>a √ó u + b √ó v = gcd(a, b)</p>
    <p>Rearrange to express gcd as a combination of a and b.  
    Can be used to find inverses modulo p by substituting u as the value to invert and v as the modulus.</p>
    <pre>
    Example:
    13 = 2(5) + 3
    5 = 1(3) + 2
    3 = 1(2) + 1
    2 = 2(1) + 0
    gcd(13, 5) = 1
    
    1 = 3 ‚àí 1(2)
    1 = 2(3) ‚àí 5
    1 = 2(13) ‚àí 4(5)
    13 √ó 2 + 5(‚àí4) = 1
    </pre>
    
    <h2>Fermat‚Äôs Little Theorem</h2>
    <p>If p is prime and a &lt; p:</p>
    <ul>
      <li>a<sup>p‚àí1</sup> ‚â° 1 (mod p)</li>
      <li>a<sup>p‚àí2</sup> ‚â° a<sup>‚àí1</sup> (mod p)</li>
    </ul>
    <p>F<sub>p</sub> = {0, 1, 2, ‚Ä¶, p‚àí1}  
    For every g ‚àà F<sub>p</sub>, there exists a multiplicative inverse d such that g √ó d ‚â° 1 (mod p).</p>
    
    <h2>Quadratic Residue</h2>
    <p>If a has a solution y in F<sub>p</sub> such that a √ó y¬≤ ‚â° something (mod p), then y is a quadratic residue; otherwise, it‚Äôs a non‚Äëresidue.</p>
    <ul>
      <li>QR √ó QR = QR</li>
      <li>QR √ó QNR = QNR</li>
      <li>QNR √ó QNR = QR</li>
    </ul>
    
    <h2>Legendre Symbol</h2>
    <p>For prime p: (a/p) = a<sup>(p‚àí1)/2</sup> mod p</p>
    <ul>
      <li>(a/p) = 1 ‚Üí a is a quadratic residue</li>
      <li>(a/p) = ‚àí1 ‚Üí a is a quadratic non‚Äëresidue</li>
      <li>(a/p) = 0 ‚Üí a ‚â° 0 (mod p)</li>
    </ul>
    
    <h2>Tonelli‚ÄìShanks Algorithm</h2>
    <ol>
      <li>Write p‚àí1 = q √ó 2<sup>s</sup> by factoring out powers of 2.</li>
      <li>Find z, a quadratic non‚Äëresidue: (z/p) = ‚àí1.</li>
      <li>Set c = z<sup>q</sup> mod p, r = a<sup>(q+1)/2</sup> mod p, t = a<sup>q</sup> mod p, m = s.</li>
      <li>Loop until t = 1:
        <ul>
          <li>Find smallest i (0 &lt; i &lt; m) such that t<sup>2<sup>i</sup></sup> = 1.</li>
          <li>b = c<sup>2<sup>m‚àíi‚àí1</sup></sup> mod p</li>
          <li>r = r √ó b mod p</li>
          <li>t = t √ó b¬≤ mod p</li>
          <li>c = b¬≤ mod p</li>
          <li>m = i</li>
        </ul>
      </li>
    </ol>
    <p>When t = 1, r is the square root of a mod p.</p>
    
    <h2>Chinese Remainder Theorem</h2>
    <p>For pairwise coprime moduli a, b, c:</p>
    <pre>
    x ‚â° y‚ÇÅ (mod a)
    x ‚â° y‚ÇÇ (mod b)
    x ‚â° y‚ÇÉ (mod c)
    </pre>
    <p>Solution: x = b√óc√ód‚ÇÅ + a√óc√ód‚ÇÇ + a√ób√ód‚ÇÉ (mod a√ób√óc),  
    where each d<sub>n</sub> is chosen so that the term ‚â° 1 mod its modulus.</p>
    
    <h2>Euler‚Äôs Totient Function</h2>
    <p>œÜ(p) = number of x in F<sub>p</sub> with gcd(p, x) = 1</p>
    <ul>
      <li>œÜ(pq) = (p‚àí1)(q‚àí1)</li>
      <li>If gcd(b, m) = 1 ‚Üí b<sup>œÜ(m)</sup> ‚â° 1 (mod m)</li>
    </ul>
    
    <h2>Binomial Expansion (mod N)</h2>
    <p>If N = pq:</p>
    <pre>
    (p + q)<sup>e</sup> mod N = p<sup>e</sup> + q<sup>e</sup> mod N
    </pre>
    <p>pq terms vanish as they are multiples of N.</p>
    
    <h2>Classic RSA</h2>
    <ol>
      <li>Choose large primes p, q.</li>
      <li>N = pq, œÜ(N) = (p‚àí1)(q‚àí1).</li>
      <li>Choose e: 1 &lt; e &lt; œÜ(N), gcd(e, œÜ(N)) = 1.</li>
      <li>Find d: e√ód ‚â° 1 (mod œÜ(N)).</li>
    </ol>
    <p>Encrypt: C = M<sup>e</sup> mod N  
    Decrypt: M = C<sup>d</sup> mod N</p>
    
    <h2>RSA Cracking Methods</h2>
    <ul>
      <li>Factor N to get p, q ‚Üí œÜ(N) ‚Üí d.</li>
      <li>Use GCD attacks, quadratic equations, Wiener's attack, etc.</li>
    </ul>
    
    <h2>Wilson‚Äôs Theorem</h2>
    <p>(p‚àí1)! ‚â° ‚àí1 (mod p) if p is prime.</p>
    </div>
  </div>
</body>
</html>
