<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
  <div class="overlay">

    <!-- ğŸ”¹ Navigation Header -->
    <div class="header">
      <a class="tab" href="../../../main.html">Introduction</a>
      <a class="tab" href="../../../resources.html">Resources</a>
      <a class="tab" href="../../../writeups.html">Writeups</a>
      <a class="tab" href="../../../misc.html">Miscellaneous</a>
      <a class="tab" href="../../../about.html">About</a>
    </div>

    <!-- ğŸ”¹ Page Content -->
    <div class="content">
    <h2>Modular Arithmetic Manipulation</h2>
    <ul>
      <li>(a + x<sub>b</sub> + x) mod p</li>
      <li>(a âˆ’ x<sub>b</sub> âˆ’ x) mod p</li>
      <li>(a Ã— x<sub>b</sub> Ã— x) mod p</li>
      <li>(a<sup>x<sub>b</sub></sup> Ã— x) mod p</li>
      <li>(a + b) mod p = (a mod p) + (b mod p)</li>
      <li>(a Ã— b) mod p = (a mod p) Ã— (b mod p)</li>
      <li>(a Ã— d<sub>b</sub> Ã— d) mod p = a Ã— b mod (p / gcd(d, p))</li>
    </ul>
    
    <h2>Greatest Common Divisor</h2>
    <p>gcd(a, b) = 1 â†’ a and b are coprime (relatively prime).  
    Used to find inverses in the Chinese Remainder Theorem.</p>
    
    <h2>Euclidâ€™s Algorithm</h2>
    <p>a = k Ã— b + c<sub>1</sub>, where c<sub>1</sub> &lt; b  
    b = k Ã— c<sub>1</sub> + c<sub>2</sub>, where c<sub>2</sub> &lt; c<sub>1</sub></p>
    <p>Continue until c<sub>n</sub> = k Ã— c<sub>n+1</sub> + 0.  
    The previous remainder is gcd(a, b).</p>
    
    <h2>Extended Euclidâ€™s Algorithm</h2>
    <p>a Ã— u + b Ã— v = gcd(a, b)</p>
    <p>Rearrange to express gcd as a combination of a and b.  
    Can be used to find inverses modulo p by substituting u as the value to invert and v as the modulus.</p>
    <pre>
    Example:
    13 = 2(5) + 3
    5 = 1(3) + 2
    3 = 1(2) + 1
    2 = 2(1) + 0
    gcd(13, 5) = 1
    
    1 = 3 âˆ’ 1(2)
    1 = 2(3) âˆ’ 5
    1 = 2(13) âˆ’ 4(5)
    13 Ã— 2 + 5(âˆ’4) = 1
    </pre>
    
    <h2>Fermatâ€™s Little Theorem</h2>
    <p>If p is prime and a &lt; p:</p>
    <ul>
      <li>a<sup>pâˆ’1</sup> â‰¡ 1 (mod p)</li>
      <li>a<sup>pâˆ’2</sup> â‰¡ a<sup>âˆ’1</sup> (mod p)</li>
    </ul>
    <p>F<sub>p</sub> = {0, 1, 2, â€¦, pâˆ’1}  
    For every g âˆˆ F<sub>p</sub>, there exists a multiplicative inverse d such that g Ã— d â‰¡ 1 (mod p).</p>
    
    <h2>Quadratic Residue</h2>
    <p>If a has a solution y in F<sub>p</sub> such that a Ã— yÂ² â‰¡ something (mod p), then y is a quadratic residue; otherwise, itâ€™s a nonâ€‘residue.</p>
    <ul>
      <li>QR Ã— QR = QR</li>
      <li>QR Ã— QNR = QNR</li>
      <li>QNR Ã— QNR = QR</li>
    </ul>
    
    <h2>Legendre Symbol</h2>
    <p>For prime p: (a/p) = a<sup>(pâˆ’1)/2</sup> mod p</p>
    <ul>
      <li>(a/p) = 1 â†’ a is a quadratic residue</li>
      <li>(a/p) = âˆ’1 â†’ a is a quadratic nonâ€‘residue</li>
      <li>(a/p) = 0 â†’ a â‰¡ 0 (mod p)</li>
    </ul>
    
    <h2>Tonelliâ€“Shanks Algorithm</h2>
    <ol>
      <li>Write pâˆ’1 = q Ã— 2<sup>s</sup> by factoring out powers of 2.</li>
      <li>Find z, a quadratic nonâ€‘residue: (z/p) = âˆ’1.</li>
      <li>Set c = z<sup>q</sup> mod p, r = a<sup>(q+1)/2</sup> mod p, t = a<sup>q</sup> mod p, m = s.</li>
      <li>Loop until t = 1:
        <ul>
          <li>Find smallest i (0 &lt; i &lt; m) such that t<sup>2<sup>i</sup></sup> = 1.</li>
          <li>b = c<sup>2<sup>mâˆ’iâˆ’1</sup></sup> mod p</li>
          <li>r = r Ã— b mod p</li>
          <li>t = t Ã— bÂ² mod p</li>
          <li>c = bÂ² mod p</li>
          <li>m = i</li>
        </ul>
      </li>
    </ol>
    <p>When t = 1, r is the square root of a mod p.</p>
    
    <h2>Chinese Remainder Theorem</h2>
    <p>For pairwise coprime moduli a, b, c:</p>
    <pre>
    x â‰¡ yâ‚ (mod a)
    x â‰¡ yâ‚‚ (mod b)
    x â‰¡ yâ‚ƒ (mod c)
    </pre>
    <p>Solution: x = bÃ—cÃ—dâ‚ + aÃ—cÃ—dâ‚‚ + aÃ—bÃ—dâ‚ƒ (mod aÃ—bÃ—c),  
    where each d<sub>n</sub> is chosen so that the term â‰¡ 1 mod its modulus.</p>
    
    <h2>Eulerâ€™s Totient Function</h2>
    <p>Ï†(p) = number of x in F<sub>p</sub> with gcd(p, x) = 1</p>
    <ul>
      <li>Ï†(pq) = (pâˆ’1)(qâˆ’1)</li>
      <li>If gcd(b, m) = 1 â†’ b<sup>Ï†(m)</sup> â‰¡ 1 (mod m)</li>
    </ul>
    
    <h2>Binomial Expansion (mod N)</h2>
    <p>If N = pq:</p>
    <pre>
    (p + q)<sup>e</sup> mod N = p<sup>e</sup> + q<sup>e</sup> mod N
    </pre>
    <p>pq terms vanish as they are multiples of N.</p>
    
    <h2>Classic RSA</h2>
    <ol>
      <li>Choose large primes p, q.</li>
      <li>N = pq, Ï†(N) = (pâˆ’1)(qâˆ’1).</li>
      <li>Choose e: 1 &lt; e &lt; Ï†(N), gcd(e, Ï†(N)) = 1.</li>
      <li>Find d: eÃ—d â‰¡ 1 (mod Ï†(N)).</li>
    </ol>
    <p>Encrypt: C = M<sup>e</sup> mod N  
    Decrypt: M = C<sup>d</sup> mod N</p>
    
    <h2>Modular Bionmials</h2>
    <h3>RSA Decoder</h3>
    <p>N = p Ã— q</p>
    <p>
      c<sub>1</sub> = (a<sub>1</sub>Â·p + b<sub>1</sub>Â·q)<sup>e<sub>1</sub></sup> mod N<br>
      c<sub>2</sub> = (a<sub>2</sub>Â·p + b<sub>2</sub>Â·q)<sup>e<sub>2</sub></sup> mod N
    </p>
    <p>
      q = gcd( (a<sub>2</sub> âˆ’ e<sub>1</sub>e<sub>2</sub> mod N) Â· (c<sub>2</sub><sup>e<sub>1</sub></sup> mod N) âˆ’ (a<sub>1</sub> âˆ’ e<sub>1</sub>e<sub>2</sub> mod N) Â· (c<sub>1</sub><sup>e<sub>2</sub></sup> mod N), N )<br>
      p = gcd( (b<sub>2</sub> âˆ’ e<sub>1</sub>e<sub>2</sub> mod N) Â· (c<sub>2</sub><sup>e<sub>1</sub></sup> mod N) âˆ’ (b<sub>1</sub> âˆ’ e<sub>1</sub>e<sub>2</sub> mod N) Â· (c<sub>1</sub><sup>e<sub>2</sub></sup> mod N), N )
    </p>
    <p>or simply p = N / q</p>
    
    <h2>Quadratic Equations</h2>
    <p>
      Ï†(N) = (p âˆ’ 1)(q âˆ’ 1) = pq âˆ’ (p + q) + 1 = N âˆ’ (p + q) + 1, hence<br>
      p + q = N âˆ’ Ï†(N) + 1
    </p>
    <p>Let p and q be the roots of a quadratic:</p>
    <p>
      (x âˆ’ p)(x âˆ’ q) = 0 â‡’ xÂ² âˆ’ (p + q)x + pq = 0
    </p>
    <p>
      Substitute pq = N and p + q = N âˆ’ Ï†(N) + 1:
    </p>
    <p>
      xÂ² âˆ’ (N âˆ’ Ï†(N) + 1)x + N = 0
    </p>
    <p>
      If the value of Ï†(N) is correct, the roots are integers, giving the factors of N.
    </p>
    
    <h2>Simple Continued Fraction / Wienerâ€™s Attack</h2>
    <p>
      Ï†(N) = (p âˆ’ 1)(q âˆ’ 1) = N âˆ’ (p + q) + 1 â‰ˆ N (since p + q â‰ª pq)
    </p>
    <p>
      Since k &gt; 0 and k âˆˆ â„¤ for ed = kÂ·Ï†(N) + 1, we have:
    </p>
    <p>
      ed âˆ’ kÂ·Ï†(N) = 1
    </p>
    <p>
      Divide both sides by dÂ·Ï†(N):
    </p>
    <p>
      e/Ï†(N) âˆ’ k/d = 1/(dÂ·Ï†(N))
    </p>
    <p>
      Since dÂ·Ï†(N) is large, 1/(dÂ·Ï†(N)) â‰ˆ 0, hence:
    </p>
    <p>
      e/Ï†(N) â‰ˆ k/d
    </p>
    <p>
      Additional constraints used to filter candidates:
    </p>
    <ul>
      <li>ed â‰¡ 1 (mod Ï†(N))</li>
      <li>Ï†(N) â‰¡ 0 (mod 2) â‡’ d should be odd; if d is even, skip</li>
      <li>If (ed âˆ’ 1)/k âˆ‰ â„¤, skip that k</li>
    </ul>
    <p>
      Use Euclidâ€™s Algorithm/continued fractions to find convergents k/d satisfying the above; then use the quadratic method to verify Ï†(N) yields integer roots for p and q.
    </p>
    
    <h3>Wienerâ€™s success conditions</h3>
    <p>
      Typically succeeds if q &lt; p &lt; 2q and d &lt; N<sup>1/4</sup> / 3.<br>
      It can still succeed in some cases even if d &gt; N<sup>1/4</sup> / 3.
    </p>
    
    <h2>Wilsonâ€™s Theorem</h2>
    <p>(pâˆ’1)! â‰¡ âˆ’1 (mod p) if p is prime.</p>
    </div>
  </div>
</body>
</html>
