<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../../style.css">
  <style>
    /* Extra centring for this page */
    .content {
      max-width: 900px;   /* keeps it from stretching too wide */
      margin: 0 auto;     /* centers horizontally */
      padding: 40px;      /* breathing room from edges */
    }
  </style>
</head>
<body>
  <div class="overlay">

    <!-- ğŸ”¹ Navigation Header -->
    <div class="header">
      <a class="tab" href="../../../main.html">Introduction</a>
      <a class="tab" href="../../../resources.html">Resources</a>
      <a class="tab" href="../../../writeups.html">Writeups</a>
      <a class="tab" href="../../../misc.html">Miscellaneous</a>
      <a class="tab" href="../../../about.html">About</a>
    </div>

    <!-- ğŸ”¹ Page Content -->
    <div class="content">
    <h2>Modular Arithmetic Manipulation</h2>
    <ul>
      <li>If a â‰¡ b (mod p), then:
        <ul>
          <li>a + x â‰¡ b + x (mod p)</li>
          <li>a âˆ’ x â‰¡ b âˆ’ x (mod p)</li>
          <li>a Â· x â‰¡ b Â· x (mod p)</li>
          <li>a<sup>x</sup> â‰¡ b<sup>x</sup> (mod p)</li>
        </ul>
      </li>
      <li>(a + b) mod p â‰¡ (a mod p + b mod p) mod p</li>
      <li>(a Â· b) mod p â‰¡ (a mod p Â· b mod p) mod p</li>
      <li>If a Â· d â‰¡ b Â· d (mod p), then a â‰¡ b (mod p / gcd(d, p))</li>
    </ul>
    
    <h2>Greatest Common Divisor</h2>
    <p>gcd(a, b) = 1 â†’ a and b are coprime (relatively prime).<br>
    Used to find inverses for the Chinese Remainder Theorem.</p>
    
    <h2>Euclidâ€™s Algorithm</h2>
    <p>a = kÂ·b + c<sub>1</sub>, where c<sub>1</sub> &lt; b<br>
    b = kÂ·c<sub>1</sub> + c<sub>2</sub>, where c<sub>2</sub> &lt; c<sub>1</sub></p>
    <p>Continue until c<sub>n</sub> = kÂ·c<sub>n+1</sub> + 0. The previous remainder is gcd(a, b).</p>
    
    <h2>Extended Euclidâ€™s Algorithm</h2>
    <p>aÂ·u + bÂ·v = gcd(a, b)</p>
    <p>Rearrange to express gcd as an integer combination of a and b. This also finds modular inverses: set u to the inverse of a modulo p when gcd(a, p) = 1.</p>
    <pre>
    Example:
    13 = 2(5) + 3
    5 = 1(3) + 2
    3 = 1(2) + 1
    2 = 2(1) + 0
    gcd(13, 5) = 1
    
    1 = 3 âˆ’ 1(2)
    1 = 2(3) âˆ’ 5
    1 = 2(13) âˆ’ 4(5)
    13 Â· 2 + 5(âˆ’4) = 1
    </pre>
    
    <h2>Fermatâ€™s Little Theorem</h2>
    <p>If p is prime and a &lt; p, then:</p>
    <ul>
      <li>a<sup>pâˆ’1</sup> â‰¡ 1 (mod p)</li>
      <li>a<sup>pâˆ’2</sup> â‰¡ a<sup>âˆ’1</sup> (mod p)</li>
    </ul>
    <p>F<sub>p</sub> = {0, 1, 2, â€¦, pâˆ’1}. For every g âˆˆ F<sub>p</sub>, there exists d such that gÂ·d â‰¡ 1 (mod p) (the multiplicative inverse).<br>
    We can use a<sup>pâˆ’2</sup> â‰¡ a<sup>âˆ’1</sup> (mod p) to find inverses when p is prime.</p>
    
    <h2>Quadratic Residue</h2>
    <p>y âˆˆ F<sub>p</sub> is a quadratic residue (QR) if âˆƒx with xÂ² â‰¡ y (mod p). Otherwise, y is a quadratic nonâ€‘residue (QNR).</p>
    <ul>
      <li>QR Â· QR = QR</li>
      <li>QR Â· QNR = QNR</li>
      <li>QNR Â· QNR = QR</li>
    </ul>
    
    <h2>Legendre Symbol</h2>
    <p>For prime p, the Legendre symbol (a/p) satisfies: (a/p) â‰¡ a<sup>(pâˆ’1)/2</sup> (mod p).</p>
    <ul>
      <li>(a/p) = 1 â†’ a is a quadratic residue (a â‰¢ 0 mod p)</li>
      <li>(a/p) = âˆ’1 â†’ a is a quadratic nonâ€‘residue (mod p)</li>
      <li>(a/p) = 0 â†’ a â‰¡ 0 (mod p)</li>
    </ul>
    
    <h2>Tonelliâ€“Shanks Algorithm</h2>
    <p>Used to find square roots of a modulo p (odd prime), when a is a quadratic residue.</p>
    <ol>
      <li>Write p âˆ’ 1 = q Â· 2<sup>s</sup> by factoring out powers of 2.</li>
      <li>Find z a QNR: (z/p) = âˆ’1.</li>
      <li>Initialize: c = z<sup>q</sup> mod p, r = a<sup>(q+1)/2</sup> mod p, t = a<sup>q</sup> mod p, m = s.</li>
      <li>Repeat until t â‰¡ 1 (mod p):
        <ul>
          <li>Find the smallest i with 0 &lt; i &lt; m such that t<sup>2<sup>i</sup></sup> â‰¡ 1 (mod p).</li>
          <li>b = c<sup>2<sup>mâˆ’iâˆ’1</sup></sup> mod p</li>
          <li>r = r Â· b mod p</li>
          <li>t = t Â· bÂ² mod p</li>
          <li>c = bÂ² mod p</li>
          <li>m = i</li>
        </ul>
      </li>
    </ol>
    <p>When t â‰¡ 1 (mod p), r is a square root of a modulo p.</p>
    <p>Special case: when s = 1, the algorithm simplifies significantly (x â‰¡ a<sup>(p+1)/4</sup> (mod p) if p â‰¡ 3 (mod 4)).</p>
    
    <h2>Chinese Remainder Theorem</h2>
    <p>This can only be used when all linear mods are coprime.</p>
    
    <pre>
    x â‰¡ yâ‚ (mod a)
    x â‰¡ yâ‚‚ (mod b)
    x â‰¡ yâ‚ƒ (mod c)
    </pre>
    
    <p>If gcd(a, b, c) = 1,</p>
    
    <pre>
    x â‰¡ b * c * dâ‚ + a * c * dâ‚‚ + a * b * dâ‚ƒ (mod a * b * c)
    </pre>
    
    <p>
    <b>Step 1:</b>  
    x â‰¡ b * c (mod a), multiply b * c by an integer dâ‚ such that:
    </p>
    
    <pre>
    x â‰¡ b * c * dâ‚ (mod a)
    </pre>
    
    <p>
    <b>Step 2:</b>  
    x â‰¡ a * c (mod b), multiply a * c by an integer dâ‚‚ such that:
    </p>
    
    <pre>
    x â‰¡ a * c * dâ‚‚ (mod b)
    </pre>
    
    <p>
    <b>Step 3:</b>  
    x â‰¡ a * b (mod c), multiply a * b by an integer dâ‚ƒ such that:
    </p>
    
    <pre>
    x â‰¡ a * b * dâ‚ƒ (mod c)
    </pre>
    
    <p>
    If x is congruent with each corresponding part, then d<sub>n</sub> â‰¡ 1 for that modulus.
    </p>
    
    <h2>Eulerâ€™s Totient Function</h2>
    <p>Ï†(m) = |{ x âˆˆ {1,â€¦,m} : gcd(x, m) = 1 }|</p>
    <ul>
      <li>Ï†(pq) = (p âˆ’ 1)(q âˆ’ 1) for distinct primes p, q</li>
      <li>If gcd(b, m) = 1, then b<sup>Ï†(m)</sup> â‰¡ 1 (mod m)</li>
    </ul>
    
    <h2>Binomial Expansion (mod N)</h2>
    <p>When N = pÂ·q (primes):</p>
    <pre>
    (p + q)<sup>e</sup> mod N â‰¡ p<sup>e</sup> + q<sup>e</sup> (mod N)
    </pre>
    <p>Cross terms are multiples of N and vanish modulo N.</p>
    
    <h2>Classic RSA</h2>
    <ol>
      <li>Choose primes p, q of similar bitâ€‘length.</li>
      <li>N = pÂ·q; Ï†(N) = (p âˆ’ 1)(q âˆ’ 1).</li>
      <li>Choose public exponent e with 1 &lt; e &lt; Ï†(N) and gcd(e, Ï†(N)) = 1.</li>
      <li>Compute private exponent d with eÂ·d â‰¡ 1 (mod Ï†(N)).</li>
    </ol>
    <p>Encrypt: C â‰¡ M<sup>e</sup> (mod N), with 0 â‰¤ M &lt; N<br>
    Decrypt: M â‰¡ C<sup>d</sup> (mod N)</p>
    
    <h3>RSA G.E.D</h3>
    <p>
    G: 1 &lt; e &lt; Ï†(N), gcd(e, Ï†(N)) = 1, and dÂ·e â‰¡ 1 (mod Ï†(N))<br>
    E: C â‰¡ M<sup>e</sup> (mod N), 0 â‰¤ M &lt; N<br>
    D: M â‰¡ C<sup>d</sup> (mod N)
    </p>
    
    <h3>To break RSA</h3>
    <p>It suffices to find Ï†(N). Since Ï†(N) = (p âˆ’ 1)(q âˆ’ 1), factoring N gives Ï†(N) and thus d from eÂ·d â‰¡ 1 (mod Ï†(N)).</p>
    
    <h2>Modular Binomials â€” RSA Decoder</h2>
    <pre>
    N = p Â· q
    câ‚ â‰¡ (aâ‚Â·p + bâ‚Â·q)<sup>eâ‚</sup> (mod N)
    câ‚‚ â‰¡ (aâ‚‚Â·p + bâ‚‚Â·q)<sup>eâ‚‚</sup> (mod N)
    
    q = gcd( (aâ‚‚ âˆ’ eâ‚eâ‚‚ mod N) Â· (câ‚‚<sup>eâ‚</sup> mod N) âˆ’ (aâ‚ âˆ’ eâ‚eâ‚‚ mod N) Â· (câ‚<sup>eâ‚‚</sup> mod N), N )
    p = gcd( (bâ‚‚ âˆ’ eâ‚eâ‚‚ mod N) Â· (câ‚‚<sup>eâ‚</sup> mod N) âˆ’ (bâ‚ âˆ’ eâ‚eâ‚‚ mod N) Â· (câ‚<sup>eâ‚‚</sup> mod N), N )
    
    or p = N / q
    </pre>
    
    <h2>Quadratic Equations (factoring via Ï†(N))</h2>
    <p>Ï†(N) = (p âˆ’ 1)(q âˆ’ 1) = pq âˆ’ (p + q) + 1 = N âˆ’ (p + q) + 1 â‡’ p + q = N âˆ’ Ï†(N) + 1</p>
    <p>Let p, q be roots of (x âˆ’ p)(x âˆ’ q) = 0 â‡’ xÂ² âˆ’ (p + q)x + pq = 0</p>
    <p>Substitute pq = N, p + q = N âˆ’ Ï†(N) + 1:</p>
    <p>xÂ² âˆ’ (N âˆ’ Ï†(N) + 1)x + N = 0</p>
    <p>If Ï†(N) is correct, the roots are integers, yielding p and q.</p>
    
    <h2>Simple Continued Fraction / Wienerâ€™s Attack</h2>
    <p>Ï†(N) = (p âˆ’ 1)(q âˆ’ 1) = N âˆ’ (p + q) + 1, and typically p + q â‰ª pq, so Ï†(N) â‰ˆ N.</p>
    <p>Since k &gt; 0 and k âˆˆ â„¤ for eÂ·d = kÂ·Ï†(N) + 1, we have:</p>
    <p>eÂ·d âˆ’ kÂ·Ï†(N) = 1</p>
    <p>Divide by dÂ·Ï†(N): e/Ï†(N) âˆ’ k/d = 1/(dÂ·Ï†(N)) â‰ˆ 0 â‡’ e/Ï†(N) â‰ˆ k/d</p>
    <ul>
      <li>Constraint: eÂ·d â‰¡ 1 (mod Ï†(N))</li>
      <li>Ï†(N) is even â‡’ d must be odd (skip even d)</li>
      <li>If (eÂ·d âˆ’ 1)/k âˆ‰ â„¤, skip that k</li>
    </ul>
    <p>Use continued fractions for e/N (or e/Ï†(N) approximation) to get convergents k/d that satisfy the constraints. Verify via the quadratic relation that Ï†(N) gives integer roots.</p>
    
    <h3>Wienerâ€™s success conditions</h3>
    <p>Works when q &lt; p &lt; 2q and d &lt; N<sup>1/4</sup>/3. It may still work in some cases even if d &gt; N<sup>1/4</sup>/3.</p>
    
    <h2>Wilsonâ€™s Theorem</h2>
    <p>(p âˆ’ 1)! â‰¡ âˆ’1 (mod p) for prime p.<br>
    Inefficient for large p; Millerâ€“Rabin is typically used for primality testing instead.</p>
    </div>
  </div>
</body>
</html>
