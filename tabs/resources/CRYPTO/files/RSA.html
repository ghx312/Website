<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../../style.css">
  <style>
    /* Extra centring for this page */
    .content {
      max-width: 900px;   /* keeps it from stretching too wide */
      margin: 0 auto;     /* centers horizontally */
      padding: 40px;      /* breathing room from edges */
    }
  </style>
</head>
<body>
  <div class="overlay">

    <!-- 🔹 Navigation Header -->
    <div class="header">
      <a class="tab" href="../../../main.html">Introduction</a>
      <a class="tab" href="../../../resources.html">Resources</a>
      <a class="tab" href="../../../writeups.html">Writeups</a>
      <a class="tab" href="../../../misc.html">Miscellaneous</a>
      <a class="tab" href="../../../about.html">About</a>
    </div>

    <!-- 🔹 Page Content -->
    <div class="content">
    <h2>Modular Arithmetic Manipulation</h2>
    <ul>
      <li>If a ≡ b (mod p), then:
        <ul>
          <li>a + x ≡ b + x (mod p)</li>
          <li>a − x ≡ b − x (mod p)</li>
          <li>a · x ≡ b · x (mod p)</li>
          <li>a<sup>x</sup> ≡ b<sup>x</sup> (mod p)</li>
        </ul>
      </li>
      <li>(a + b) mod p ≡ (a mod p + b mod p) mod p</li>
      <li>(a · b) mod p ≡ (a mod p · b mod p) mod p</li>
      <li>If a · d ≡ b · d (mod p), then a ≡ b (mod p / gcd(d, p))</li>
    </ul>
    
    <h2>Greatest Common Divisor</h2>
    <p>gcd(a, b) = 1 → a and b are coprime (relatively prime).<br>
    Used to find inverses for the Chinese Remainder Theorem.</p>
    
    <h2>Euclid’s Algorithm</h2>
    <p>a = k·b + c<sub>1</sub>, where c<sub>1</sub> &lt; b<br>
    b = k·c<sub>1</sub> + c<sub>2</sub>, where c<sub>2</sub> &lt; c<sub>1</sub></p>
    <p>Continue until c<sub>n</sub> = k·c<sub>n+1</sub> + 0. The previous remainder is gcd(a, b).</p>
    
    <h2>Extended Euclid’s Algorithm</h2>
    <p>a·u + b·v = gcd(a, b)</p>
    <p>Rearrange to express gcd as an integer combination of a and b. This also finds modular inverses: set u to the inverse of a modulo p when gcd(a, p) = 1.</p>
    <pre>
    Example:
    13 = 2(5) + 3
    5 = 1(3) + 2
    3 = 1(2) + 1
    2 = 2(1) + 0
    gcd(13, 5) = 1
    
    1 = 3 − 1(2)
    1 = 2(3) − 5
    1 = 2(13) − 4(5)
    13 · 2 + 5(−4) = 1
    </pre>
    
    <h2>Fermat’s Little Theorem</h2>
    <p>If p is prime and a &lt; p, then:</p>
    <ul>
      <li>a<sup>p−1</sup> ≡ 1 (mod p)</li>
      <li>a<sup>p−2</sup> ≡ a<sup>−1</sup> (mod p)</li>
    </ul>
    <p>F<sub>p</sub> = {0, 1, 2, …, p−1}. For every g ∈ F<sub>p</sub>, there exists d such that g·d ≡ 1 (mod p) (the multiplicative inverse).<br>
    We can use a<sup>p−2</sup> ≡ a<sup>−1</sup> (mod p) to find inverses when p is prime.</p>
    
    <h2>Quadratic Residue</h2>
    <p>y ∈ F<sub>p</sub> is a quadratic residue (QR) if ∃x with x² ≡ y (mod p). Otherwise, y is a quadratic non‑residue (QNR).</p>
    <ul>
      <li>QR · QR = QR</li>
      <li>QR · QNR = QNR</li>
      <li>QNR · QNR = QR</li>
    </ul>
    
    <h2>Legendre Symbol</h2>
    <p>For prime p, the Legendre symbol (a/p) satisfies: (a/p) ≡ a<sup>(p−1)/2</sup> (mod p).</p>
    <ul>
      <li>(a/p) = 1 → a is a quadratic residue (a ≢ 0 mod p)</li>
      <li>(a/p) = −1 → a is a quadratic non‑residue (mod p)</li>
      <li>(a/p) = 0 → a ≡ 0 (mod p)</li>
    </ul>
    
    <h2>Tonelli–Shanks Algorithm</h2>
    <p>Used to find square roots of a modulo p (odd prime), when a is a quadratic residue.</p>
    <ol>
      <li>Write p − 1 = q · 2<sup>s</sup> by factoring out powers of 2.</li>
      <li>Find z a QNR: (z/p) = −1.</li>
      <li>Initialize: c = z<sup>q</sup> mod p, r = a<sup>(q+1)/2</sup> mod p, t = a<sup>q</sup> mod p, m = s.</li>
      <li>Repeat until t ≡ 1 (mod p):
        <ul>
          <li>Find the smallest i with 0 &lt; i &lt; m such that t<sup>2<sup>i</sup></sup> ≡ 1 (mod p).</li>
          <li>b = c<sup>2<sup>m−i−1</sup></sup> mod p</li>
          <li>r = r · b mod p</li>
          <li>t = t · b² mod p</li>
          <li>c = b² mod p</li>
          <li>m = i</li>
        </ul>
      </li>
    </ol>
    <p>When t ≡ 1 (mod p), r is a square root of a modulo p.</p>
    <p>Special case: when s = 1, the algorithm simplifies significantly (x ≡ a<sup>(p+1)/4</sup> (mod p) if p ≡ 3 (mod 4)).</p>
    
    <h2>Chinese Remainder Theorem</h2>
    <p>This can only be used when all linear mods are coprime.</p>
    
    <pre>
    x ≡ y₁ (mod a)
    x ≡ y₂ (mod b)
    x ≡ y₃ (mod c)
    </pre>
    
    <p>If gcd(a, b, c) = 1,</p>
    
    <pre>
    x ≡ b * c * d₁ + a * c * d₂ + a * b * d₃ (mod a * b * c)
    </pre>
    
    <p>
    <b>Step 1:</b>  
    x ≡ b * c (mod a), multiply b * c by an integer d₁ such that:
    </p>
    
    <pre>
    x ≡ b * c * d₁ (mod a)
    </pre>
    
    <p>
    <b>Step 2:</b>  
    x ≡ a * c (mod b), multiply a * c by an integer d₂ such that:
    </p>
    
    <pre>
    x ≡ a * c * d₂ (mod b)
    </pre>
    
    <p>
    <b>Step 3:</b>  
    x ≡ a * b (mod c), multiply a * b by an integer d₃ such that:
    </p>
    
    <pre>
    x ≡ a * b * d₃ (mod c)
    </pre>
    
    <p>
    If x is congruent with each corresponding part, then d<sub>n</sub> ≡ 1 for that modulus.
    </p>
    
    <h2>Euler’s Totient Function</h2>
    <p>φ(m) = |{ x ∈ {1,…,m} : gcd(x, m) = 1 }|</p>
    <ul>
      <li>φ(pq) = (p − 1)(q − 1) for distinct primes p, q</li>
      <li>If gcd(b, m) = 1, then b<sup>φ(m)</sup> ≡ 1 (mod m)</li>
    </ul>
    
    <h2>Binomial Expansion (mod N)</h2>
    <p>When N = p·q (primes):</p>
    <pre>
    (p + q)<sup>e</sup> mod N ≡ p<sup>e</sup> + q<sup>e</sup> (mod N)
    </pre>
    <p>Cross terms are multiples of N and vanish modulo N.</p>
    
    <h2>Classic RSA</h2>
    <ol>
      <li>Choose primes p, q of similar bit‑length.</li>
      <li>N = p·q; φ(N) = (p − 1)(q − 1).</li>
      <li>Choose public exponent e with 1 &lt; e &lt; φ(N) and gcd(e, φ(N)) = 1.</li>
      <li>Compute private exponent d with e·d ≡ 1 (mod φ(N)).</li>
    </ol>
    <p>Encrypt: C ≡ M<sup>e</sup> (mod N), with 0 ≤ M &lt; N<br>
    Decrypt: M ≡ C<sup>d</sup> (mod N)</p>
    
    <h3>RSA G.E.D</h3>
    <p>
    G: 1 &lt; e &lt; φ(N), gcd(e, φ(N)) = 1, and d·e ≡ 1 (mod φ(N))<br>
    E: C ≡ M<sup>e</sup> (mod N), 0 ≤ M &lt; N<br>
    D: M ≡ C<sup>d</sup> (mod N)
    </p>
    
    <h3>To break RSA</h3>
    <p>It suffices to find φ(N). Since φ(N) = (p − 1)(q − 1), factoring N gives φ(N) and thus d from e·d ≡ 1 (mod φ(N)).</p>
    
    <h2>Modular Binomials — RSA Decoder</h2>
    <pre>
    N = p · q
    c₁ ≡ (a₁·p + b₁·q)<sup>e₁</sup> (mod N)
    c₂ ≡ (a₂·p + b₂·q)<sup>e₂</sup> (mod N)
    
    q = gcd( (a₂ − e₁e₂ mod N) · (c₂<sup>e₁</sup> mod N) − (a₁ − e₁e₂ mod N) · (c₁<sup>e₂</sup> mod N), N )
    p = gcd( (b₂ − e₁e₂ mod N) · (c₂<sup>e₁</sup> mod N) − (b₁ − e₁e₂ mod N) · (c₁<sup>e₂</sup> mod N), N )
    
    or p = N / q
    </pre>
    
    <h2>Quadratic Equations (factoring via φ(N))</h2>
    <p>φ(N) = (p − 1)(q − 1) = pq − (p + q) + 1 = N − (p + q) + 1 ⇒ p + q = N − φ(N) + 1</p>
    <p>Let p, q be roots of (x − p)(x − q) = 0 ⇒ x² − (p + q)x + pq = 0</p>
    <p>Substitute pq = N, p + q = N − φ(N) + 1:</p>
    <p>x² − (N − φ(N) + 1)x + N = 0</p>
    <p>If φ(N) is correct, the roots are integers, yielding p and q.</p>
    
    <h2>Simple Continued Fraction / Wiener’s Attack</h2>
    <p>φ(N) = (p − 1)(q − 1) = N − (p + q) + 1, and typically p + q ≪ pq, so φ(N) ≈ N.</p>
    <p>Since k &gt; 0 and k ∈ ℤ for e·d = k·φ(N) + 1, we have:</p>
    <p>e·d − k·φ(N) = 1</p>
    <p>Divide by d·φ(N): e/φ(N) − k/d = 1/(d·φ(N)) ≈ 0 ⇒ e/φ(N) ≈ k/d</p>
    <ul>
      <li>Constraint: e·d ≡ 1 (mod φ(N))</li>
      <li>φ(N) is even ⇒ d must be odd (skip even d)</li>
      <li>If (e·d − 1)/k ∉ ℤ, skip that k</li>
    </ul>
    <p>Use continued fractions for e/N (or e/φ(N) approximation) to get convergents k/d that satisfy the constraints. Verify via the quadratic relation that φ(N) gives integer roots.</p>
    
    <h3>Wiener’s success conditions</h3>
    <p>Works when q &lt; p &lt; 2q and d &lt; N<sup>1/4</sup>/3. It may still work in some cases even if d &gt; N<sup>1/4</sup>/3.</p>
    
    <h2>Wilson’s Theorem</h2>
    <p>(p − 1)! ≡ −1 (mod p) for prime p.<br>
    Inefficient for large p; Miller–Rabin is typically used for primality testing instead.</p>
    </div>
  </div>
</body>
</html>
