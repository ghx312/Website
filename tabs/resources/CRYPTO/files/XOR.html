<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../../style.css">
  <style>
    /* Extra centring for this page */
    .content {
      max-width: 900px;   /* keeps it from stretching too wide */
      margin: 0 auto;     /* centers horizontally */
      padding: 40px;      /* breathing room from edges */
    }
  </style>
</head>
<body>
  <div class="overlay">

    <!-- 🔹 Navigation Header -->
    <div class="header">
      <a class="tab" href="../../../main.html">Introduction</a>
      <a class="tab" href="../../../resources.html">Resources</a>
      <a class="tab" href="../../../writeups.html">Writeups</a>
      <a class="tab" href="../../../misc.html">Miscellaneous</a>
      <a class="tab" href="../../../about.html">About</a>
    </div>

    <!-- 🔹 Page Content -->
    <div class="content">
    <h2>XOR Syntax</h2>
    <p>
    XOR can be represented as <code>^</code> or the symbol <code>⊕</code>.  
    It uses symmetric encryption — both the encryption function E() and the decryption function G() use the same key.
    </p>
    
    <h2>XOR Properties</h2>
    <ul>
      <li>A ⊕ B = B ⊕ A (Order does not matter, Commutative)</li>
      <li>(A ⊕ B) ⊕ C = A ⊕ (B ⊕ C) (Associative)</li>
      <li>A ⊕ 0 = A (Identity Element)</li>
      <li>A ⊕ A = 0<sub>n</sub> (Self‑Inversing)</li>
      <li>A ⊕ Ā = 1<sub>n</sub> (where n is the length of A, and Ā is the bitwise complement of A)</li>
      <li>0 ⊕ 0 = 0, 1 ⊕ 0 = 1, 1 ⊕ 1 = 0 (Bitwise Operation)</li>
      <li>If C ⊕ B = A, then B = C ⊕ A, and C = A ⊕ B</li>
    </ul>
    
    <p><strong>Flag ⊕ Secret Key = Ciphertext</strong><br>
    <strong>Ciphertext ⊕ Secret Key = Flag</strong></p>
    
    <h2>Python</h2>
    <pre>
    pip install pwntools
    from pwntools import xor
    xor(BYTES, BYTES)  # XORs bytes together
    bytes.fromhex(HEX) # convert Hex to Bytes
    </pre>
    
    <h2>Partial XORing</h2>
    <p>
    Flag{???} ⊕ SecretKey = Ciphertext  
    The secret key used is not known, but with the Ciphertext and flag format, it can be partially revealed.
    </p>
    <p>
    Ciphertext ⊕ flag format = Part of the secret key
    </p>
    
    <h2>One‑Time Pad</h2>
    <p>
    One‑Time Pad has Perfect Secrecy and hence Perfect Indistinguishability.  
    m₁, c, sk ∈ {0,1}<sup>l</sup> where l is the security parameter (possible type of input, key, and output for this encryption system — in this case binary, where l is the length of the message).
    </p>
    <ul>
      <li>G(1<sup>l</sup>) chooses sk at random from {0,1}<sup>l</sup></li>
      <li>E(sk, m) = sk ⊕ m = c</li>
      <li>D(sk, c) = sk ⊕ c = m</li>
    </ul>
    <p>
    This encryption scheme achieves Perfect Secrecy because there is only one key for a message that matches a predetermined ciphertext, and vice versa, making all messages and ciphertexts equally likely.
    </p>
    
    <h2>Advanced XOR Obfuscation</h2>
    <ul>
      <li>Use multi‑byte keys to remove repetitiveness</li>
      <li>Vary byte key lengths</li>
      <li>Dynamic Key Generation (key generated from part of the plaintext)</li>
      <li>Use other mathematical algorithms</li>
    </ul>
    
    <h2>Vulnerabilities</h2>
    <h3>Key Reuse Vulnerability</h3>
    <pre>
    M₁ ⊕ K = C₁
    M₂ ⊕ K = C₂
    M₁ ⊕ M₂ = C₁ ⊕ C₂
    </pre>
    <p>This can reveal the plaintext through statistical analysis or a known‑plaintext attack.</p>
    
    <h3>Known‑Plaintext Attack</h3>
    <pre>
    M ⊕ K = C
    </pre>
    <p>Knowing part of the plaintext can reveal part of the key, increasing vulnerability for future attacks.</p>
    
    <h3>Bit Flipping Attack (Linear Separability)</h3>
    <p>
    By flipping bits in a ciphertext, you can manipulate the message because XOR is linear — any change in one variable changes the others.
    </p>
    
    <h3>Poor Randomness of Key</h3>
    <p>
    If the key is not truly random, statistical analysis can crack the key and recover the message.
    </p>
    
    <h3>Single‑Byte XOR Vulnerability</h3>
    <p>
    Frequency analysis can reveal the key byte.
    </p>
    
    <h3>Frequency Analysis</h3>
    <p>
    XOR is not safe from frequency analysis when the key is reused, due to poor diffusion properties.
    </p>
    
    <h3>TLS 1.0 CBC Mode</h3>
    <p>
    This cryptographic protocol can be attacked by exploiting XOR’s vulnerabilities via chosen‑plaintext and BEAST attacks, targeting the XOR of IVs and message data.
    </p>
    
    <h3>Advanced Obfuscation Attack</h3>
    <ul>
      <li>Statistical and differential analysis to detect repeated samples or weak points</li>
      <li>Known‑plaintext / chosen‑plaintext attacks</li>
      <li>Binary structure recognition (e.g., JPG header FFD8)</li>
    </ul>
    </div>
  </div>
</body>
</html>
