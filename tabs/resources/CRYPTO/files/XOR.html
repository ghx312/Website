<!DOCTYPE html>
<html>
<head>
  <title>Cryptography</title>
  <meta charset="UTF-8">
  <!-- Import Fredoka font -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Go up one folder to get style.css -->
  <link rel="stylesheet" href="../../../../style.css">
  <style>
    /* Extra centring for this page */
    .content {
      max-width: 900px;   /* keeps it from stretching too wide */
      margin: 0 auto;     /* centers horizontally */
      padding: 40px;      /* breathing room from edges */
    }
  </style>
</head>
<body>
  <div class="overlay">

    <!-- ğŸ”¹ Navigation Header -->
    <div class="header">
      <a class="tab" href="../../../main.html">Introduction</a>
      <a class="tab" href="../../../resources.html">Resources</a>
      <a class="tab" href="../../../writeups.html">Writeups</a>
      <a class="tab" href="../../../misc.html">Miscellaneous</a>
      <a class="tab" href="../../../about.html">About</a>
    </div>

    <!-- ğŸ”¹ Page Content -->
    <div class="content">
    <h2>XOR Syntax</h2>
    <p>
    XOR can be represented as <code>^</code> or the symbol <code>âŠ•</code>.  
    It uses symmetric encryption â€” both the encryption function E() and the decryption function G() use the same key.
    </p>
    
    <h2>XOR Properties</h2>
    <ul>
      <li>A âŠ• B = B âŠ• A (Order does not matter, Commutative)</li>
      <li>(A âŠ• B) âŠ• C = A âŠ• (B âŠ• C) (Associative)</li>
      <li>A âŠ• 0 = A (Identity Element)</li>
      <li>A âŠ• A = 0<sub>n</sub> (Selfâ€‘Inversing)</li>
      <li>A âŠ• Ä€ = 1<sub>n</sub> (where n is the length of A, and Ä€ is the bitwise complement of A)</li>
      <li>0 âŠ• 0 = 0, 1 âŠ• 0 = 1, 1 âŠ• 1 = 0 (Bitwise Operation)</li>
      <li>If C âŠ• B = A, then B = C âŠ• A, and C = A âŠ• B</li>
    </ul>
    
    <p><strong>Flag âŠ• Secret Key = Ciphertext</strong><br>
    <strong>Ciphertext âŠ• Secret Key = Flag</strong></p>
    
    <h2>Python</h2>
    <pre>
    pip install pwntools
    from pwntools import xor
    xor(BYTES, BYTES)  # XORs bytes together
    bytes.fromhex(HEX) # convert Hex to Bytes
    </pre>
    
    <h2>Partial XORing</h2>
    <p>
    Flag{???} âŠ• SecretKey = Ciphertext  
    The secret key used is not known, but with the Ciphertext and flag format, it can be partially revealed.
    </p>
    <p>
    Ciphertext âŠ• flag format = Part of the secret key
    </p>
    
    <h2>Oneâ€‘Time Pad</h2>
    <p>
    Oneâ€‘Time Pad has Perfect Secrecy and hence Perfect Indistinguishability.  
    mâ‚, c, sk âˆˆ {0,1}<sup>l</sup> where l is the security parameter (possible type of input, key, and output for this encryption system â€” in this case binary, where l is the length of the message).
    </p>
    <ul>
      <li>G(1<sup>l</sup>) chooses sk at random from {0,1}<sup>l</sup></li>
      <li>E(sk, m) = sk âŠ• m = c</li>
      <li>D(sk, c) = sk âŠ• c = m</li>
    </ul>
    <p>
    This encryption scheme achieves Perfect Secrecy because there is only one key for a message that matches a predetermined ciphertext, and vice versa, making all messages and ciphertexts equally likely.
    </p>
    
    <h2>Advanced XOR Obfuscation</h2>
    <ul>
      <li>Use multiâ€‘byte keys to remove repetitiveness</li>
      <li>Vary byte key lengths</li>
      <li>Dynamic Key Generation (key generated from part of the plaintext)</li>
      <li>Use other mathematical algorithms</li>
    </ul>
    
    <h2>Vulnerabilities</h2>
    <h3>Key Reuse Vulnerability</h3>
    <pre>
    Mâ‚ âŠ• K = Câ‚
    Mâ‚‚ âŠ• K = Câ‚‚
    Mâ‚ âŠ• Mâ‚‚ = Câ‚ âŠ• Câ‚‚
    </pre>
    <p>This can reveal the plaintext through statistical analysis or a knownâ€‘plaintext attack.</p>
    
    <h3>Knownâ€‘Plaintext Attack</h3>
    <pre>
    M âŠ• K = C
    </pre>
    <p>Knowing part of the plaintext can reveal part of the key, increasing vulnerability for future attacks.</p>
    
    <h3>Bit Flipping Attack (Linear Separability)</h3>
    <p>
    By flipping bits in a ciphertext, you can manipulate the message because XOR is linear â€” any change in one variable changes the others.
    </p>
    
    <h3>Poor Randomness of Key</h3>
    <p>
    If the key is not truly random, statistical analysis can crack the key and recover the message.
    </p>
    
    <h3>Singleâ€‘Byte XOR Vulnerability</h3>
    <p>
    Frequency analysis can reveal the key byte.
    </p>
    
    <h3>Frequency Analysis</h3>
    <p>
    XOR is not safe from frequency analysis when the key is reused, due to poor diffusion properties.
    </p>
    
    <h3>TLS 1.0 CBC Mode</h3>
    <p>
    This cryptographic protocol can be attacked by exploiting XORâ€™s vulnerabilities via chosenâ€‘plaintext and BEAST attacks, targeting the XOR of IVs and message data.
    </p>
    
    <h3>Advanced Obfuscation Attack</h3>
    <ul>
      <li>Statistical and differential analysis to detect repeated samples or weak points</li>
      <li>Knownâ€‘plaintext / chosenâ€‘plaintext attacks</li>
      <li>Binary structure recognition (e.g., JPG header FFD8)</li>
    </ul>
    </div>
  </div>
</body>
</html>
